<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Vyse Documentation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.1.</strong> Cheatsheet</a></li><li class="chapter-item expanded "><a href="lang-basics/syntax.html"><strong aria-hidden="true">1.2.</strong> Syntax</a></li><li class="chapter-item expanded "><a href="lang-basics/variables.html"><strong aria-hidden="true">1.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="lang-basics/primitives.html"><strong aria-hidden="true">1.4.</strong> Data Types</a></li></ol></li><li class="chapter-item expanded "><a href="object-model/oop.html"><strong aria-hidden="true">2.</strong> OOP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="object-model/prototype.html"><strong aria-hidden="true">2.1.</strong> Prototypes</a></li><li class="chapter-item expanded "><a href="object-model/methods.html"><strong aria-hidden="true">2.2.</strong> Methods</a></li><li class="chapter-item expanded "><a href="object-model/oop-tables.html"><strong aria-hidden="true">2.3.</strong> OOP with tables</a></li><li class="chapter-item expanded "><a href="object-model/op-overload.html"><strong aria-hidden="true">2.4.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="object-model/classes.html"><strong aria-hidden="true">2.5.</strong> Classes and Inheritance</a></li></ol></li><li class="chapter-item expanded "><a href="functional/hof.html"><strong aria-hidden="true">3.</strong> Higher Order Functions</a></li><li class="chapter-item expanded affix "><li class="part-title">Standard Library</li><li class="chapter-item expanded "><a href="stdlib/strings.html"><strong aria-hidden="true">4.</strong> string</a></li><li class="chapter-item expanded "><a href="stdlib/List.html"><strong aria-hidden="true">5.</strong> list</a></li><li class="chapter-item expanded "><a href="stdlib/table.html"><strong aria-hidden="true">6.</strong> table</a></li><li class="chapter-item expanded "><a href="stdlib/math.html"><strong aria-hidden="true">7.</strong> math</a></li><li class="chapter-item expanded "><a href="stdlib/io.html"><strong aria-hidden="true">8.</strong> io</a></li><li class="chapter-item expanded "><a href="stdlib/os.html"><strong aria-hidden="true">9.</strong> os</a></li><li class="chapter-item expanded affix "><li class="part-title">Showcase</li><li class="chapter-item expanded "><a href="showcase/sample-projects.html"><strong aria-hidden="true">10.</strong> Sample Projects</a></li><li class="chapter-item expanded affix "><li class="part-title">Embedding</li><li class="chapter-item expanded "><a href="embed/embed.html"><strong aria-hidden="true">11.</strong> Installing from source</a></li><li class="chapter-item expanded "><a href="embed/api.html"><strong aria-hidden="true">12.</strong> C++ API</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Vyse Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Vyse is a general purpose programming language inspired by Lua, and is designed for
embedding in C++ applications such as game engines.</p>
<h2 id="design-goals"><a class="header" href="#design-goals">Design goals.</a></h2>
<p>From the very first day of development, Vyse has been made with specific design goals in mind.</p>
<ul>
<li>Familiar to programmers coming from JavaScript or the C-family of languages.</li>
<li>Minimalistic design</li>
<li>Powerful and flexible paradigm.</li>
<li>Light and noise-free syntax.</li>
<li>Easy to embed in C++ applications and link statically.</li>
<li>Similar feature set and the easy learning curve of Lua.</li>
</ul>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives.</a></h2>
<p>Want to explore other options? Fortunately there are several languages for embeddable scripting.
A few you might find fun to explore are:</p>
<ul>
<li>Lua</li>
<li>Wren</li>
<li>Angelscript</li>
<li>Haxe</li>
<li>Scheme</li>
<li>Squirrel</li>
<li>Chaiscript</li>
</ul>
<h1 id="cheatsheet"><a class="header" href="#cheatsheet">Cheatsheet</a></h1>
<p>This section contains a brief overview of the Vyse. If you have some prior experience with programming in C or JS like languages, this should help you cover the basics pretty quickly!</p>
<p>If not, consider this snippet an &quot;Eagle eye view&quot; of the territory. You can copy and paste the following snippet into a file and play around with it.</p>
<pre><code class="language-vyse">-- comments begin with '--' and are ignored by 
-- the interpreter.
print(&quot;Welcome to Vyse!&quot;)

-- constants declared with the 'const' keyword
const pi = 3.1415162
-- mutable variables declared with 'let'
let r = input(&quot;Enter radius: &quot;)

-- lambda functions
const area = /r -&gt; pi * r ** 2
-- ** for exponents

if r &lt;= 0 {
  print(&quot;Radius must be greater than zero!&quot;);
} else {
  print(&quot;Area = &quot;, area(r)) 
}

-- Functions can alternatively be declared
-- with the 'fn' keyword.
fn make_adder(x) {
  -- Functions can return and recieve
  -- other functions too!
  return fn(y) {
    return x + y
  } 
}

const add10 = make_adder(10)
print('10 + 20 =', add10(20)) -- 10 + 20 = 30

-- Tables are data-structures
-- used to store key-value pairs of any
-- kind.

const Tom = {
  species: 'cat',
  age: 2
}

-- Tables can be indexed with the '.' or '[]' operators.
print('Tom is a', Tom.species)
print('Tom is', Tom['age'], 'years old'.)

-- Arrays are like tables, but they can
-- only be indexed with numeric keys and
-- are better for iterating on.

const my_array = ['ten', 10, false, [1, 2, 3]]

-- The looping syntax is similar to that of Lua
for i = 1, 4 {
  print(my_array[i])
}

-- for loops can take a 3rd operand 'step',
-- which is the amount to change the iterator variable
-- by every iteration. By default, it's value is 1.
for i = 4, 1, -1 {
  -- prints the array items in reverse
  print(my_array[i])
}

-- '#' operator returns the size of an array.
for i = 1, #my_array {
  print(i, my_array[i])
}

-- arrays are 'iterable' and can be iterated upon
-- with a more convinient syntax.
for el in array 
  print(el)


-- Prototypes are a concept that can help
-- simulate OOP in vyse.

const t = { a: 1, b: 2 }
print(t.c) -- nil

-- When a key is not found within the
-- set of the object's own properties,
-- vyse will search the object's 'prototype'
-- (if any) for the property.

const mt = { b: 10, c: 3 }
setproto(t, mt)
print(t.c) -- 3
print(t.b) -- 2

-- Note that a search for a key always begins at
-- the object itself and goes up the prototype chain,
-- so t.b is still 2.

-- OOP
-- Declaring and using classes
-- is very straightforward.
class Animal {
  init(sound) {
    self.sound = sound
  }

  make_sound() {
    print(self.sound)
  }
}

const spike = Animal(&quot;woof!&quot;)
-- methods are called with ':'
animal:make_sound()

-- classes can be extended with '&lt;'
class Human &lt; Animal {
  init(name) {
    super('hi!') -- super class constructor
    self.name = name
  }

  greet() {
    make_sound()
    print('I am ', self.name)
  }
}

const bob = Human('Bob')
bob:greet() 'Hi! I am Bob'
bob:make_sound() 'Hi!'

</code></pre>
<p>Note that the cheatsheet above is meant to be an 'overview' and therefore does not include all the features, constructs and details about Vyse.</p>
<h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<h3 id="comments"><a class="header" href="#comments">Comments</a></h3>
<p>Comments are ignored by the interpreter completely.
Single line comments begin with <code>--</code> and Multiline comments
are between <code>/*</code> and <code>*/</code>.</p>
<pre><code class="language-vyse">-- Single line comment
/* multi
   line
   comment
*/
</code></pre>
<h3 id="blocks"><a class="header" href="#blocks">Blocks</a></h3>
<p>Blocks demarcate chunks of code. Variable declarations inside a block will shadow
the declarations in the outer scope.</p>
<pre><code class="language-vyse">const pet = 'rabbit'

{
  const pet = 'cat'
  print(pet) -- cat
}

print(pet) -- 'rabbit'

</code></pre>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>Strings in Vyse are surrounded either in single quote or double quotes,
and may contain newlines. Note that strings can only contain ASCII characters
at the moment, and you will have to use utf8 library to work with strings containing
utf8 characters.</p>
<pre><code class="language-vyse">const mystring = &quot;Hello! This is a string&quot;;
const myotherstring = &quot; This
  string
  spans
  multiple
  lines&quot;;
</code></pre>
<h3 id="keywords"><a class="header" href="#keywords">Keywords</a></h3>
<p>Vyse has very few keywords that you'll need to keep in mind.
These words are reserved and cannot be used as variable names.</p>
<pre><code>let const while for in fn break 
class true false if else
</code></pre>
<h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<p>Variable come in two flavors, mutable and immutable.
Immutable variables once declared, cannot be re-assigned to.</p>
<pre><code class="language-vyse">const myvar = 10
myvar = 20 -- Error: Attempt to mutate a variable declared 'const'.

let my_other_var = 10
my_other_var = 20 -- Ok
</code></pre>
<p>Note however, that variables that are <code>const</code> can still be mutated
if they are not primitive data types. Only re-assignment is forbidden.</p>
<pre><code class="language-vyse">const my_table = { my_key: 'my_value' }
my_table.my_key = 123 -- ok

my_table = {} -- Error: Attempt to mutate a variable declared 'const'.
</code></pre>
<h2 id="globals-and-locals"><a class="header" href="#globals-and-locals">Globals and Locals.</a></h2>
<p>Another way to categorize variables is either as 'locals' or 'globals'.
A global variable is accessible everywhere and is shared across modules.
A local variable is scoped to its surrounding block.</p>
<pre><code class="language-vyse">global x = 'global'
let y = 'local'

-- Both globals and locals display similar
-- behavior when shadowed.
{
  x = 123
  y = 456
  z = 789
  print(x, y, z) -- 123 456 789
}

print(x, y, z) -- global local nil
</code></pre>
<p>All global variables in Vyse can be found in special predefined table called '<code>_G</code>'.
They can therefore me modified and accessed from the table itself.</p>
<pre><code class="language-vyse">_G.x = 42
print(x) -- 42
</code></pre>
<p>At this point, you might be wondering why bother with global variables at all since
they're nearly the same as locals. To answer this, we will explore global variables
further in a later section.</p>
<h2 id="data-types"><a class="header" href="#data-types">Data Types</a></h2>
<p>In totala vyse provides the following native data types:</p>
<ol>
<li>number</li>
<li>boolean</li>
<li>nil </li>
<li>string </li>
<li>list</li>
<li>table </li>
<li>function</li>
</ol>
<p>From the above, only the first 4 are considered <em>primitive</em> data types.</p>
<h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<p>A number in vyse is a 64-bit double precision IEEE float.
All numeric values in vyse are represented using this type.
There are a variety of ways you can write numbers in vyse source
code, but they all behave the same way and use the same representation
underneath.</p>
<pre><code class="language-vyse">123
12.3
0xff -- Hex (255)
0b101 -- Binary (5)
1e2 -- Scientific notation (100)
</code></pre>
<h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>Booleans are as simple as you would expect. A boolean can
take up two values, 'true' or 'false'. A value is called
'truthy' if it is considered <em>&quot;true&quot;</em> under certain contexts.
For example, an if statement.</p>
<pre><code class="language-vyse">let is_truthy = \x -&gt; {
  if x print('yes')
  else print('no')
} 

is_truthy('a')   -- yes 
is_truthy('')    -- yes
is_truthy(0)     -- yes
is_truthy(1)     -- yes
is_truthy(true)  -- yes
is_truthy({})    -- yes
is_truthy([])    -- yes
is_truthy(false) -- no
is_truthy(nil)   -- no
</code></pre>
<p>One can run the code snippet above to verify that only
a <code>false</code> boolean value or a <code>nil</code> value are considered 'falsy'. 
All other values evaluate to <code>true</code> when truthy-ness is concerned.</p>
<h2 id="nil"><a class="header" href="#nil">Nil</a></h2>
<p>The <code>nil</code> data type referes to a single <code>nil</code> value. It is used to signal 
the absence of any data.</p>
<pre><code class="language-vyse">fn substring(s, from, len) {
  if (strlen(s) &lt; from) return nil
  sub = ''
  for i = 0, len {
    sub = sub .. s[from + len]
  }
  return sub
}
</code></pre>
<p>Notice how when no other suitable value is found, we return <code>nil</code> in the above function.</p>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>Strings are a contiguous buffer of ascii characters.
Strings are immutable.
Once created, the contents of a string cannot be changed.</p>
<pre><code class="language-vyse">const s = 'abxde'
print(s[0]) -- a
s[2] = 'c' -- Error: Cannot mutate a string literal.
</code></pre>
<p>To get a modified string, you have to create a new string.</p>
<pre><code class="language-vyse">const new_s = s:slice(0, 2) .. 'c' .. s:slice(3, 2)
print(new_s) -- abcde
</code></pre>
<p>The <code>slice(start, length)</code> method is used to 'slice' a string by extracting
a substring from it. The original string <code>s</code> is left unchanged throughout this
commotion.</p>
<p>Note that while creating strings at runtime can be somewhat expensive compared to 
numbers, booleans and nils, comparing strings with the <code>==</code> operator is nearly as
fast as comparing numbers. 
This is because vyse performs string interning to keep
string comparisons fast and efficient.</p>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<p>Lists are similar to dynamic arrays in other programming languages.
A list is declared by putting comma separated elements inside of <code>[</code>
and <code>]</code>.</p>
<ul>
<li>The <code>#</code> operator is used to get the length of a list.</li>
<li>Lists are indexed from <code>0</code>.</li>
<li>The size of lists can change at runtime.</li>
<li>Indexing a list with an invalid index (-1 or a value greater than it's length) will throw an error.</li>
</ul>
<pre><code class="language-vyse">let arr = [1, 2, 3]
for el in arr {
  print(el)
}
</code></pre>
<p><strong>Common methods and functions on lists</strong>:</p>
<ul>
<li><code>list:push(item)</code>: Appends <code>item</code> to the end of the list.</li>
<li><code>list:pop()</code>: Removes the last item from the list and returns it.</li>
<li><code>len(list)</code>:  Returns the length of the list.</li>
<li><code>list:map(fn)</code>: Creates a new list <code>ls</code> where <code>ls[i]</code> is <code>fn(list[i])</code></li>
</ul>
<p>For more methods and free functions to operate on lists, refer to the standard library
documentation.</p>
<h2 id="table"><a class="header" href="#table">Table</a></h2>
<p>Tables are Vyse's core data structure used to store key-value pairs. 
They're similar to <code>Map</code>s in JavaScript or tables in Lua.</p>
<pre><code class="language-vyse">const point = { x: 1, y: 2 }
print(point['x'], point.y) -- 1 2
</code></pre>
<p>Tables are rather simple data structures in terms of usage, but they can
prove to be very powerful. We will see in the coming sections how tables
can be used to model OOP like encapsulation.</p>
<h1 id="oop-in-vyse"><a class="header" href="#oop-in-vyse">OOP in Vyse.</a></h1>
<p>Vyse has a flexible yet powerful object model.
Prototype based inheritance is one of the language's core features.</p>
<p>As with everything else, the OOP in Vyse is a cherry-picked combination of
features from Javascript and Lua, with some icing on top.</p>
<p>Continue reading to learn more about Object Oriented Programming in Vyse.</p>
<h1 id="prototypes"><a class="header" href="#prototypes">Prototypes</a></h1>
<p>Prototypes are the core feature of Vyse's object model. Every table has 
a &quot;prototype&quot; table (also called proto-table).
By default, the prototype is <code>nil</code>.
When a queried property is missing from a table, its prototype chain is queried bottom up for the same key.</p>
<pre><code class="language-snap">const tbl   = { a: 1, b: 2 }
const proto = { c: 3, d: 4 }

setproto(tbl, proto) -- set tbl's meta table to meta

print(tbl.a, tbl.b, tbl.c, tbl.d) -- 1 2 3 4
</code></pre>
<p>The <code>setproto</code> builtin function can be used to set a table's prototype.
When a property field is not found in a table itself, it's prototype is
queried for the same.</p>
<h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<p>Tables can have properties that are functions. Functions can either be invoked normally by
accessing them or by using the <code>:</code> operator. When called using <code>:</code>, the functions behave as methods.</p>
<pre><code class="language-vy">const cat = {
  sound: 'meow'
  speak: fn (self) {
    print(self.sound)
  }
}

cat:speak() -- 'meow'
cat.speak(cat) -- 'meow'
</code></pre>
<p>Note that <code>table:method()</code> is equivalent to <code>table.method(table)</code>.
Methods have an extra first parameter that refers to the table
itself. By convention, this parameter is called 'self'. But any other name
also suffices.</p>
<h3 id="shorthand-syntax"><a class="header" href="#shorthand-syntax">Shorthand Syntax</a></h3>
<p>To make methods look more natural and convenient, there exists a short-hand
syntax.</p>
<pre><code class="language-vyse">const dog = {
  sound: 'woof!',
  speak() {
    print(self.sound)
  }
}

dog:bark() -- woof!
dog.bark(dog) -- woof!

-- Can also be called like a free function
-- on other objects.
dog.bark(cat) -- meow
</code></pre>
<p>The <code>self</code> parameter is implicit and hidden when a method is defined with the shorthand
syntax.</p>
<h3 id="defining-methods-outside-a-table"><a class="header" href="#defining-methods-outside-a-table">Defining Methods Outside A Table.</a></h3>
<p>Methods can be declared outside the table's body with the usual function
definition syntax.</p>
<pre><code class="language-vyse">const cat = { sound = 'meow' }

fn cat:meow() {
  print(self.sound)
}

cat:mow() -- 'meow'
</code></pre>
<p>Methods will later come in handy when we delve into the object oriented programming
model.</p>
<h1 id="oop-with-tables"><a class="header" href="#oop-with-tables">OOP with tables</a></h1>
<p>Equipped with the knowledge of <a href="object-model/./prototype.html">prototypes</a> and <a href="object-model/./methods.html">methods</a>,
we are now ready to explore vyse's object oriented programming capabilities.</p>
<p>To demonstrate, we will start off by designing a simple 2D Vector class.
For now, let's just assume the following simple features:</p>
<ul>
<li>Create a 2D vector with <code>Vec2:make(x, y)</code></li>
<li>Access <code>x</code> and <code>y</code> properties as <code>v.x</code> and <code>v.y</code>.</li>
<li>Calculate a vector's magnitude with <code>v:mag()</code>.</li>
</ul>
<pre><code class="language-vyse">const Vec2 = {
  make(x, y) {
    const v = {x: x, y: y}
    setproto(v, self)
    return v
  }

  mag() {
    return math.sqrt(self.x ** 2 + self.y ** 2)
  }
}
</code></pre>
<p>Writing simple tests for the vector class doesn't take a lot of effort.</p>
<pre><code class="language-vyse">let pt = Vec2:make(2, 3) -- 1
assert(pt.x == 2 and pt.y == 3) -- 2
assert(pt:mag() == 13) -- 3
</code></pre>
<p>The <code>assert</code> builtin throws an error if the first argument is falsy (either <code>false</code> or <code>nil</code>).
Given the implementation of <code>Vec2</code> class we described, the above assertions should pass.</p>
<p><code>Vec2</code> is a table with 2 member functions, <code>make</code> and <code>mag</code>.
The <code>make</code> method first creates an empty table <code>v</code> and sets it's <code>x</code> and <code>y</code> fields to the provided
parameters. Next, the prototype of <code>x</code> is set to <code>Vec2</code> itself.</p>
<p>We then create <code>pt</code>, an 'instance' of <code>Vec2</code> (line 1).</p>
<p>The table <code>pt</code> itself doesn't have any immediate member called 'mag', so when the lookup is performed
for a method with the name <code>mag</code> in line 3, the <code>mag</code> method from the original <code>Vec2</code> class is instead used.</p>
<h3 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h3>
<p>Inheritance can similarly be modelled with prototypes and the <code>setproto</code> builtin.
Imagine you're writing code for your command line roguelike game.</p>
<pre><code class="language-vyse">const Enemy = {
  make(x, y, hp) {
    const e = {}
    e.pos = Vec2:make(x, y)
    e.hp = hp
    return setproto(e, self)
  }

  log() {
    print(self.pos.x, self.pos.y)
  }
}
</code></pre>
<p>This table is now ready to serve as our base enemy class that other
classes can derive from. An enemy is capable of holding some data and
displaying it's position.</p>
<pre><code class="language-vyse">const Goblin = {
  make(x, y, hp, dmg) {
    const gob = Enemy:make(x, y, hp)
    gob.damage = dmg
    return setproto(gob, self)
  }

  attack(target) {
    print(&quot;stole &quot;, damage, &quot;gold from&quot;, target)
  }
}

setproto(Goblin, Enemy)
</code></pre>
<p>The call to <code>setproto</code> on the last line sets <code>Goblin</code>'s base class (prototype) to <code>Enemy</code>.</p>
<pre><code class="language-vyse">const spleen = Goblin(0, 0, 10, 2)
spleen:log() -- 0 0 
spleen:attack('squee') -- stole 2 gold from squee
</code></pre>
<p>Our character spleen is now able to exhibit the behavior of both an Enemy and a Goblin.
This simple object modelling strategy can be expanded to multiple facets of software
architecture in Vyse.</p>
<h1 id="operator-overloading"><a class="header" href="#operator-overloading">Operator Overloading</a></h1>
<p>Vyse has several logical and arithmetic operators.
The behavior of these operators are well defined when the operands
are of the expected data types (e.g <code>number</code> operands for <code>+</code>).</p>
<p>It is also possible to define the behavior of several of these 
operators for user-defined data types.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Let us recollect the implementation of a simple Vector class defined
<a href="object-model/./oop-tables.html">earlier</a>.</p>
<pre><code class="language-vyse">const Vec2 = {
  make(x, y) {
    const v = {x: x, y: y}
    setproto(v, self)
    return v
  }

  mag() {
    return math.sqrt(self.x ** 2 + self.y ** 2)
  }
}
</code></pre>
<p>Vectors are very often used in data visualization and game programming.
We would like to include the functionality to add together two vectors.
This can very easily be done by attaching a method.</p>
<pre><code class="language-vyse">fn Vec2.add(a, b) {
  return Vec2:make(a.x + b.x, a.y + b.y)
}
</code></pre>
<p>We can now add together vectors by calling this method that behaves like a
static member.</p>
<pre><code class="language-vyse">const a = Vec2:make(1, 2)
const b = Vec2:make(2, 3)

const c = Vec2.add(a, b)
print(c.x, c.y) --  3 5
</code></pre>
<p>It is often advantageous to both the programmer and the reader to use the usual
mathematical symbols (here <code>+</code>) when defining such constructs. For instance, many
would prefer <code>a + b</code> over <code>Vec2.add(a, b)</code>. This is made possible in vyse with the
help of proto-methods. For the <code>+</code> operator, the <code>__add</code> proto-method is used.</p>
<pre><code class="language-vyse">fn Vec2.__add(a, b) {
  return Vec2:make(a.x + b.x, a.y + b.y)
}
</code></pre>
<p>Once a proto-method is defined on an object's prototype, this is called whenever
the event associated with the protomethod is invoked. Now, we can add together
vectors with the <code>+</code> operator. </p>
<p>(Note that we use <code>Vec2.__add</code> when defining the method instead of <code>:</code>. We do not
want any hidden <code>self</code> parameter in the protomethod)</p>
<pre><code class="language-vyse">const a = Vec2:make(1, 2)
const b = Vec2:make(2, 3)

const c = a + b
print(c.x, c.y) -- 3 5
</code></pre>
<h2 id="overloadable-operators"><a class="header" href="#overloadable-operators">Overloadable operators</a></h2>
<p>A table representing all the overloadable operators
and the method names is listed below for reference:</p>
<table><thead><tr><th align="left">Operator</th><th align="left">Method</th><th align="left">Arity</th></tr></thead><tbody>
<tr><td align="left">+</td><td align="left">__add</td><td align="left">2</td></tr>
<tr><td align="left">+ (unary)</td><td align="left">__unp</td><td align="left">1</td></tr>
<tr><td align="left">-</td><td align="left">__sub</td><td align="left">2</td></tr>
<tr><td align="left">- (unary)</td><td align="left">__unm</td><td align="left">1</td></tr>
<tr><td align="left">/</td><td align="left">__div</td><td align="left">2</td></tr>
<tr><td align="left">%</td><td align="left">__mod</td><td align="left">2</td></tr>
<tr><td align="left">**</td><td align="left">__exp</td><td align="left">2</td></tr>
<tr><td align="left">&gt;</td><td align="left">__gt</td><td align="left">2</td></tr>
<tr><td align="left">&lt;</td><td align="left">__lt</td><td align="left">2</td></tr>
<tr><td align="left">&gt;=</td><td align="left">__gte</td><td align="left">2</td></tr>
<tr><td align="left">&lt;=</td><td align="left">__lte</td><td align="left">2</td></tr>
<tr><td align="left">!</td><td align="left">__not</td><td align="left">1</td></tr>
<tr><td align="left">^</td><td align="left">__xor</td><td align="left">2</td></tr>
<tr><td align="left">&amp;</td><td align="left">__band</td><td align="left">2</td></tr>
<tr><td align="left">|</td><td align="left">__bor</td><td align="left">2</td></tr>
<tr><td align="left">&lt;&lt;</td><td align="left">__bsl</td><td align="left">2</td></tr>
<tr><td align="left">&gt;&gt;</td><td align="left">__bsr</td><td align="left">2</td></tr>
<tr><td align="left">~</td><td align="left">__bnot</td><td align="left">1</td></tr>
<tr><td align="left">.</td><td align="left">__indx</td><td align="left">2</td></tr>
<tr><td align="left">==</td><td align="left">__eq</td><td align="left">2</td></tr>
<tr><td align="left">!=</td><td align="left">__neq</td><td align="left">2</td></tr>
<tr><td align="left">..</td><td align="left">__concat</td><td align="left">2</td></tr>
<tr><td align="left">()</td><td align="left">__call</td><td align="left">any</td></tr>
<tr><td align="left">[string coercion]</td><td align="left">__tostr</td><td align="left">1</td></tr>
</tbody></table>
<h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<p><strong>[TODO]</strong></p>
<h1 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher Order Functions</a></h1>
<p>Functions in class enjoy first class privelege.
All functions can be passed around as arguments, declared in nested scopes
and returned from other functions just like string and number values.</p>
<pre><code class="language-vyse">fn make_adder(x) {
  return fn(y) {
    return x + y
  }
}

const add10 = make_adder(10)
print(add10(20)) -- 30
print(add10(30)) -- 40
</code></pre>
<p>Notice how the anonymous function returned by <code>make_adder</code> is
able to use the variable <code>x</code> even after it goes out of scope.
Functions are able to capture their lexically enclosing environments
and therefore and use variables even after they go out of scope.</p>
<p>All functions in vyse have this property, and are therefore called
'Closures'.</p>
<pre><code class="language-vyse">fn func() {
  let value = 10
  return {
    set(x) { value = x    },  
    get()  { return value }
   } 
}

const t = func()
print(t.get()) -- 10
t.set(20)
print(t.get()) -- 20
</code></pre>
<p>Note the consistent behavior of the <code>get</code> and <code>set</code> methods in
reading from and writing to the same storage location <code>value</code>.</p>
<p>Higher order functions can be immensely useful, especially if you
want to use functional programming paradigm and patterns.</p>
<h1 id="strings-1"><a class="header" href="#strings-1">Strings</a></h1>
<p><strong>[TODO]</strong></p>
<h1 id="list-1"><a class="header" href="#list-1">List</a></h1>
<p><strong>[TODO]</strong></p>
<h1 id="table-1"><a class="header" href="#table-1">Table</a></h1>
<p><strong>[TODO]</strong></p>
<h1 id="math"><a class="header" href="#math">Math</a></h1>
<h1 id="io"><a class="header" href="#io">I/O</a></h1>
<p><strong>[TODO]</strong></p>
<h1 id="os"><a class="header" href="#os">os</a></h1>
<p><strong>[TODO]</strong></p>
<h1 id="sample-projects"><a class="header" href="#sample-projects">Sample Projects</a></h1>
<p><strong>[TODO]</strong></p>
<h1 id="installing-from-source"><a class="header" href="#installing-from-source">Installing from source</a></h1>
<p><strong>[TODO]</strong></p>
<h1 id="api"><a class="header" href="#api">API</a></h1>
<p><strong>[TODO]</strong></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
